/**\n * Security Test Suite for TutorConnect\n * Tests authentication, authorization, and security measures\n */\n\nimport { describe, test, expect, beforeAll, afterAll, beforeEach } from '@jest/globals';\nimport { NextRequest, NextResponse } from 'next/server';\nimport { \n  generateAccessToken, \n  generateRefreshToken, \n  verifyAccessToken,\n  validateTokenStructure,\n  generateTokenFingerprint,\n  isTokenExpired\n} from '@/lib/jwt';\nimport { authMiddleware, AuthRateLimiter } from '@/middleware/auth';\nimport { \n  securityMiddleware, \n  corsMiddleware,\n  extractClientIP,\n  SlidingWindowRateLimit\n} from '@/middleware/security';\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\ndescribe('Security Test Suite', () => {\n  let testUser: any;\n  \n  beforeAll(async () => {\n    // Create test user\n    testUser = await prisma.user.create({\n      data: {\n        email: 'security.test@example.com',\n        password: '$2a$12$test.hashed.password',\n        name: 'Security Test User',\n        region: 'OSLO',\n        isActive: true,\n        emailVerified: new Date(),\n      },\n    });\n  });\n\n  afterAll(async () => {\n    // Cleanup\n    if (testUser) {\n      await prisma.user.delete({\n        where: { id: testUser.id },\n      });\n    }\n    await prisma.$disconnect();\n  });\n\n  describe('JWT Security', () => {\n    test('should generate secure access tokens', async () => {\n      const token = await generateAccessToken({\n        userId: testUser.id,\n        email: testUser.email,\n        name: testUser.name,\n        isActive: true,\n        region: 'OSLO',\n      });\n\n      expect(token).toBeDefined();\n      expect(typeof token).toBe('string');\n      expect(token.split('.')).toHaveLength(3);\n      \n      // Verify token structure\n      const structure = validateTokenStructure(token);\n      expect(structure.isValid).toBe(true);\n    });\n\n    test('should generate different tokens for same user', async () => {\n      const token1 = await generateAccessToken({\n        userId: testUser.id,\n        email: testUser.email,\n        name: testUser.name,\n        isActive: true,\n        region: 'OSLO',\n      });\n\n      const token2 = await generateAccessToken({\n        userId: testUser.id,\n        email: testUser.email,\n        name: testUser.name,\n        isActive: true,\n        region: 'OSLO',\n      });\n\n      expect(token1).not.toBe(token2);\n    });\n\n    test('should verify valid tokens', async () => {\n      const token = await generateAccessToken({\n        userId: testUser.id,\n        email: testUser.email,\n        name: testUser.name,\n        isActive: true,\n        region: 'OSLO',\n      });\n\n      const payload = await verifyAccessToken(token);\n      expect(payload.sub).toBe(testUser.id);\n      expect(payload.email).toBe(testUser.email);\n      expect(payload.type).toBe('access');\n    });\n\n    test('should reject invalid tokens', async () => {\n      const invalidToken = 'invalid.token.here';\n      \n      await expect(verifyAccessToken(invalidToken)).rejects.toThrow();\n    });\n\n    test('should detect expired tokens', () => {\n      // Create a token payload with past expiry\n      const expiredPayload = {\n        exp: Math.floor(Date.now() / 1000) - 3600, // 1 hour ago\n        sub: 'user123',\n      };\n      \n      const header = Buffer.from(JSON.stringify({ alg: 'HS256', typ: 'JWT' })).toString('base64url');\n      const payload = Buffer.from(JSON.stringify(expiredPayload)).toString('base64url');\n      const mockToken = `${header}.${payload}.signature`;\n      \n      expect(isTokenExpired(mockToken)).toBe(true);\n    });\n\n    test('should generate consistent fingerprints', () => {\n      const token = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImp0aSI6IjlmOWQ2MzM2LTFiZjMtNGVlNS1hN2RhLTI4YzRmMTAyZTNmOSIsImlhdCI6MTU4NjI3NjIxNCwiZXhwIjoxNTg2Mjc5ODE0fQ.signature';\n      \n      const fingerprint1 = generateTokenFingerprint(token);\n      const fingerprint2 = generateTokenFingerprint(token);\n      \n      expect(fingerprint1).toBe(fingerprint2);\n      expect(fingerprint1).toHaveLength(16);\n    });\n  });\n\n  describe('Rate Limiting', () => {\n    beforeEach(() => {\n      // Reset rate limiter state\n      AuthRateLimiter.clearAttempts('test-key');\n    });\n\n    test('should allow requests within limits', () => {\n      const key = 'test-ip-123';\n      \n      for (let i = 0; i < 5; i++) {\n        expect(AuthRateLimiter.isRateLimited(key, 5, 60000)).toBe(false);\n        AuthRateLimiter.recordAttempt(key, 60000);\n      }\n    });\n\n    test('should block requests exceeding limits', () => {\n      const key = 'test-ip-456';\n      \n      // Make 5 attempts\n      for (let i = 0; i < 5; i++) {\n        AuthRateLimiter.recordAttempt(key, 60000);\n      }\n      \n      expect(AuthRateLimiter.isRateLimited(key, 5, 60000)).toBe(true);\n    });\n\n    test('should reset after time window', async () => {\n      const key = 'test-ip-789';\n      const windowMs = 100; // 100ms window\n      \n      // Fill up the rate limit\n      for (let i = 0; i < 3; i++) {\n        AuthRateLimiter.recordAttempt(key, windowMs);\n      }\n      \n      expect(AuthRateLimiter.isRateLimited(key, 3, windowMs)).toBe(true);\n      \n      // Wait for window to expire\n      await new Promise(resolve => setTimeout(resolve, windowMs + 10));\n      \n      expect(AuthRateLimiter.isRateLimited(key, 3, windowMs)).toBe(false);\n    });\n\n    test('sliding window rate limiter should work correctly', () => {\n      const rateLimiter = new SlidingWindowRateLimit(1000, 3); // 3 requests per second\n      const key = 'test-user';\n      \n      // Should allow first 3 requests\n      expect(rateLimiter.isAllowed(key)).toBe(true);\n      expect(rateLimiter.isAllowed(key)).toBe(true);\n      expect(rateLimiter.isAllowed(key)).toBe(true);\n      \n      // Should block 4th request\n      expect(rateLimiter.isAllowed(key)).toBe(false);\n      \n      // Check remaining requests\n      expect(rateLimiter.getRemainingRequests(key)).toBe(0);\n    });\n  });\n\n  describe('Security Headers', () => {\n    test('should apply security headers via middleware', () => {\n      const request = new NextRequest('http://localhost:3000/api/test');\n      const response = securityMiddleware(request);\n      \n      // Middleware returns null to continue processing\n      expect(response).toBe(null);\n    });\n\n    test('should handle CORS preflight requests', () => {\n      const request = new NextRequest('http://localhost:3000/api/test', {\n        method: 'OPTIONS',\n        headers: {\n          'origin': 'http://localhost:3000',\n          'access-control-request-method': 'POST',\n          'access-control-request-headers': 'content-type,authorization',\n        },\n      });\n      \n      const response = corsMiddleware(request);\n      \n      expect(response).toBeInstanceOf(NextResponse);\n      if (response) {\n        expect(response.status).toBe(200);\n        expect(response.headers.get('access-control-allow-origin')).toBe('http://localhost:3000');\n      }\n    });\n  });\n\n  describe('IP Extraction', () => {\n    test('should extract IP from X-Forwarded-For header', () => {\n      const request = new NextRequest('http://localhost:3000/api/test', {\n        headers: {\n          'x-forwarded-for': '192.168.1.100, 10.0.0.1',\n        },\n      });\n      \n      const ip = extractClientIP(request);\n      expect(ip).toBe('192.168.1.100');\n    });\n\n    test('should extract IP from X-Real-IP header', () => {\n      const request = new NextRequest('http://localhost:3000/api/test', {\n        headers: {\n          'x-real-ip': '203.0.113.1',\n        },\n      });\n      \n      const ip = extractClientIP(request);\n      expect(ip).toBe('203.0.113.1');\n    });\n\n    test('should fallback to localhost for missing headers', () => {\n      const request = new NextRequest('http://localhost:3000/api/test');\n      \n      const ip = extractClientIP(request);\n      expect(ip).toBe('127.0.0.1');\n    });\n  });\n\n  describe('Authentication Middleware', () => {\n    test('should reject requests without tokens', async () => {\n      const request = new NextRequest('http://localhost:3000/api/protected');\n      \n      await expect(authMiddleware(request)).rejects.toThrow('Authentication token required');\n    });\n\n    test('should reject requests with invalid tokens', async () => {\n      const request = new NextRequest('http://localhost:3000/api/protected', {\n        headers: {\n          'authorization': 'Bearer invalid-token',\n        },\n      });\n      \n      await expect(authMiddleware(request)).rejects.toThrow();\n    });\n\n    test('should accept requests with valid tokens', async () => {\n      const token = await generateAccessToken({\n        userId: testUser.id,\n        email: testUser.email,\n        name: testUser.name,\n        isActive: true,\n        region: 'OSLO',\n      });\n      \n      const request = new NextRequest('http://localhost:3000/api/protected', {\n        headers: {\n          'authorization': `Bearer ${token}`,\n        },\n      }) as any;\n      \n      const result = await authMiddleware(request);\n      expect(result).toBe(null); // Continue processing\n      expect(request.user).toBeDefined();\n      expect(request.user.id).toBe(testUser.id);\n    });\n  });\n\n  describe('Token Structure Validation', () => {\n    test('should validate correct JWT structure', () => {\n      const validToken = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImp0aSI6IjlmOWQ2MzM2LTFiZjMtNGVlNS1hN2RhLTI4YzRmMTAyZTNmOSIsImlhdCI6MTU4NjI3NjIxNCwiZXhwIjoxNTg2Mjc5ODE0fQ.signature';\n      \n      const result = validateTokenStructure(validToken);\n      expect(result.isValid).toBe(true);\n      expect(result.error).toBeUndefined();\n    });\n\n    test('should reject malformed tokens', () => {\n      const malformedTokens = [\n        'invalid',\n        'one.two',\n        'one.two.three.four',\n        '.two.three',\n        'one..three',\n        '',\n        null,\n        undefined,\n      ];\n      \n      malformedTokens.forEach(token => {\n        const result = validateTokenStructure(token as string);\n        expect(result.isValid).toBe(false);\n        expect(result.error).toBeDefined();\n      });\n    });\n\n    test('should reject tokens with invalid base64url encoding', () => {\n      const invalidToken = 'invalid-base64.invalid-base64.invalid-base64';\n      \n      const result = validateTokenStructure(invalidToken);\n      expect(result.isValid).toBe(false);\n      expect(result.error).toBe('Invalid token structure');\n    });\n  });\n\n  describe('Security Logging', () => {\n    test('should generate consistent fingerprints for same tokens', () => {\n      const token = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.test.payload';\n      const fingerprint1 = generateTokenFingerprint(token);\n      const fingerprint2 = generateTokenFingerprint(token);\n      \n      expect(fingerprint1).toBe(fingerprint2);\n      expect(fingerprint1).toMatch(/^[a-f0-9]{16}$/);\n    });\n\n    test('should generate different fingerprints for different tokens', () => {\n      const token1 = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.test.payload1';\n      const token2 = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.test.payload2';\n      \n      const fingerprint1 = generateTokenFingerprint(token1);\n      const fingerprint2 = generateTokenFingerprint(token2);\n      \n      expect(fingerprint1).not.toBe(fingerprint2);\n    });\n  });\n\n  describe('Refresh Token Security', () => {\n    test('should generate secure refresh tokens', async () => {\n      const refreshToken = await generateRefreshToken({\n        userId: testUser.id,\n        email: testUser.email,\n        name: testUser.name,\n        version: 1,\n      });\n      \n      expect(refreshToken).toBeDefined();\n      expect(typeof refreshToken).toBe('string');\n      expect(refreshToken.split('.')).toHaveLength(3);\n      \n      const structure = validateTokenStructure(refreshToken);\n      expect(structure.isValid).toBe(true);\n    });\n\n    test('should include version in refresh tokens', async () => {\n      const refreshToken = await generateRefreshToken({\n        userId: testUser.id,\n        email: testUser.email,\n        name: testUser.name,\n        version: 5,\n      });\n      \n      // Decode payload to check version\n      const [, payloadBase64] = refreshToken.split('.');\n      const payload = JSON.parse(\n        Buffer.from(payloadBase64, 'base64url').toString('utf-8')\n      );\n      \n      expect(payload.version).toBe(5);\n      expect(payload.type).toBe('refresh');\n    });\n  });\n\n  describe('Rate Limiting Advanced Features', () => {\n    test('should track suspicious activity', () => {\n      const key = 'suspicious-ip';\n      \n      // Record suspicious attempts\n      for (let i = 0; i < 3; i++) {\n        AuthRateLimiter.recordAttempt(key, 60000, true);\n      }\n      \n      const attemptInfo = AuthRateLimiter.getAttemptInfo(key);\n      expect(attemptInfo?.suspicious).toBe(true);\n      expect(attemptInfo?.count).toBe(3);\n    });\n\n    test('should blacklist IPs with excessive attempts', () => {\n      const key = 'blacklist-test-ip';\n      const ip = key.split(':')[0];\n      \n      // Record 25 attempts (over the blacklist threshold)\n      for (let i = 0; i < 25; i++) {\n        AuthRateLimiter.recordAttempt(key, 60000, true);\n      }\n      \n      expect(AuthRateLimiter.isBlacklisted(ip)).toBe(true);\n      expect(AuthRateLimiter.isRateLimited(key)).toBe(true);\n    });\n  });\n\n  describe('Environment Security', () => {\n    test('should validate JWT secret configuration', () => {\n      // These should be set in test environment\n      expect(process.env.JWT_ACCESS_SECRET).toBeDefined();\n      expect(process.env.JWT_REFRESH_SECRET).toBeDefined();\n      \n      // Secrets should be different\n      expect(process.env.JWT_ACCESS_SECRET).not.toBe(process.env.JWT_REFRESH_SECRET);\n      \n      // Secrets should be sufficiently long\n      if (process.env.JWT_ACCESS_SECRET) {\n        expect(process.env.JWT_ACCESS_SECRET.length).toBeGreaterThanOrEqual(32);\n      }\n      if (process.env.JWT_REFRESH_SECRET) {\n        expect(process.env.JWT_REFRESH_SECRET.length).toBeGreaterThanOrEqual(32);\n      }\n    });\n  });\n});