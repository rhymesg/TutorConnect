/**\n * End-to-End Security Tests for TutorConnect\n * Tests security measures from a user perspective\n */\n\nimport { test, expect, Page, BrowserContext } from '@playwright/test';\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\ntest.describe('Security E2E Tests', () => {\n  let testUser: any;\n  let context: BrowserContext;\n  let page: Page;\n\n  test.beforeAll(async ({ browser }) => {\n    // Create isolated context for security tests\n    context = await browser.newContext({\n      ignoreHTTPSErrors: false,\n      javaScriptEnabled: true,\n    });\n    \n    page = await context.newPage();\n    \n    // Create test user\n    testUser = await prisma.user.create({\n      data: {\n        email: 'security.e2e@example.com',\n        password: '$2a$12$test.hashed.password',\n        name: 'Security E2E User',\n        region: 'OSLO',\n        isActive: true,\n        emailVerified: new Date(),\n      },\n    });\n  });\n\n  test.afterAll(async () => {\n    // Cleanup\n    if (testUser) {\n      await prisma.user.delete({\n        where: { id: testUser.id },\n      });\n    }\n    await context.close();\n    await prisma.$disconnect();\n  });\n\n  test.describe('HTTP Security Headers', () => {\n    test('should include security headers in responses', async () => {\n      const response = await page.goto('http://localhost:3000');\n      \n      expect(response?.status()).toBe(200);\n      \n      // Check security headers\n      const headers = response?.headers();\n      expect(headers?.['x-content-type-options']).toBe('nosniff');\n      expect(headers?.['x-frame-options']).toBe('DENY');\n      expect(headers?.['x-xss-protection']).toBe('1; mode=block');\n      expect(headers?.['referrer-policy']).toBe('strict-origin-when-cross-origin');\n      expect(headers?.['content-security-policy']).toContain(\"default-src 'self'\");\n    });\n\n    test('should include HSTS header in production', async () => {\n      const response = await page.goto('http://localhost:3000');\n      const headers = response?.headers();\n      \n      if (process.env.NODE_ENV === 'production') {\n        expect(headers?.['strict-transport-security']).toContain('max-age=');\n      }\n    });\n\n    test('should include CSP nonce header', async () => {\n      const response = await page.goto('http://localhost:3000');\n      const headers = response?.headers();\n      \n      expect(headers?.['x-csp-nonce']).toBeDefined();\n      expect(headers?.['x-csp-nonce']).toMatch(/^[A-Za-z0-9+/=]+$/);\n    });\n  });\n\n  test.describe('Authentication Security', () => {\n    test('should enforce authentication on protected pages', async () => {\n      await page.goto('http://localhost:3000/dashboard');\n      \n      // Should redirect to login or show login form\n      await expect(page).toHaveURL(/login|auth/);\n    });\n\n    test('should prevent SQL injection in login form', async () => {\n      await page.goto('http://localhost:3000/auth/login');\n      \n      // Attempt SQL injection\n      await page.fill('input[name=\"email\"]', \"'; DROP TABLE users; --\");\n      await page.fill('input[name=\"password\"]', 'password');\n      await page.click('button[type=\"submit\"]');\n      \n      // Should show validation error, not crash\n      await expect(page.locator('.error')).toBeVisible();\n    });\n\n    test('should prevent XSS in login form', async () => {\n      await page.goto('http://localhost:3000/auth/login');\n      \n      // Attempt XSS\n      const xssPayload = '<script>alert(\"XSS\")</script>';\n      await page.fill('input[name=\"email\"]', xssPayload);\n      await page.fill('input[name=\"password\"]', 'password');\n      await page.click('button[type=\"submit\"]');\n      \n      // XSS should not execute\n      const alertPromise = page.waitForEvent('dialog', { timeout: 1000 }).catch(() => null);\n      const alert = await alertPromise;\n      expect(alert).toBeNull();\n    });\n\n    test('should implement rate limiting on login attempts', async () => {\n      await page.goto('http://localhost:3000/auth/login');\n      \n      // Attempt multiple failed logins\n      for (let i = 0; i < 6; i++) {\n        await page.fill('input[name=\"email\"]', 'test@example.com');\n        await page.fill('input[name=\"password\"]', 'wrongpassword');\n        await page.click('button[type=\"submit\"]');\n        await page.waitForTimeout(100);\n      }\n      \n      // Should show rate limit error\n      await expect(page.locator('.error')).toContainText(/rate limit|too many/i);\n    });\n  });\n\n  test.describe('CSRF Protection', () => {\n    test('should include CSRF token in forms', async () => {\n      await page.goto('http://localhost:3000/auth/register');\n      \n      // Check for CSRF token or equivalent protection\n      const metaToken = await page.locator('meta[name=\"csrf-token\"]').getAttribute('content');\n      const hiddenInput = await page.locator('input[type=\"hidden\"][name*=\"csrf\"]').count();\n      \n      // Should have either meta tag or hidden input for CSRF protection\n      expect(metaToken || hiddenInput > 0).toBeTruthy();\n    });\n\n    test('should reject requests without proper CSRF protection', async () => {\n      // This would require more complex setup to test actual CSRF attacks\n      // For now, we'll check that forms include proper protections\n      await page.goto('http://localhost:3000/auth/register');\n      \n      const form = page.locator('form');\n      await expect(form).toBeVisible();\n      \n      // Forms should have proper method and action attributes\n      const method = await form.getAttribute('method');\n      expect(method?.toUpperCase()).toBe('POST');\n    });\n  });\n\n  test.describe('Content Security Policy', () => {\n    test('should block inline scripts without nonce', async () => {\n      await page.goto('http://localhost:3000');\n      \n      // Try to inject inline script\n      const scriptError = await page.evaluate(() => {\n        try {\n          const script = document.createElement('script');\n          script.innerHTML = 'window.injectedScript = true;';\n          document.head.appendChild(script);\n          return false;\n        } catch (e) {\n          return true;\n        }\n      });\n      \n      // Should be blocked by CSP or throw error\n      expect(scriptError || !await page.evaluate(() => window.injectedScript)).toBeTruthy();\n    });\n\n    test('should block loading external resources from unauthorized domains', async () => {\n      await page.goto('http://localhost:3000');\n      \n      // Monitor console for CSP violations\n      const cspViolations: string[] = [];\n      page.on('console', msg => {\n        if (msg.type() === 'error' && msg.text().includes('Content Security Policy')) {\n          cspViolations.push(msg.text());\n        }\n      });\n      \n      // Try to load external resource\n      await page.evaluate(() => {\n        const img = document.createElement('img');\n        img.src = 'http://evil.com/image.png';\n        document.body.appendChild(img);\n      });\n      \n      // Wait a bit for CSP violation to be reported\n      await page.waitForTimeout(500);\n      \n      // Should have CSP violations for unauthorized domains\n      // (This test may need adjustment based on actual CSP configuration)\n    });\n  });\n\n  test.describe('Session Security', () => {\n    test('should set secure session cookies', async () => {\n      await page.goto('http://localhost:3000/auth/login');\n      \n      // Login with valid credentials\n      await page.fill('input[name=\"email\"]', testUser.email);\n      await page.fill('input[name=\"password\"]', 'TestPassword123!');\n      await page.click('button[type=\"submit\"]');\n      \n      // Wait for login to complete\n      await page.waitForTimeout(1000);\n      \n      // Check cookies\n      const cookies = await context.cookies();\n      const sessionCookies = cookies.filter(cookie => \n        cookie.name.includes('token') || cookie.name.includes('session')\n      );\n      \n      sessionCookies.forEach(cookie => {\n        if (process.env.NODE_ENV === 'production') {\n          expect(cookie.secure).toBe(true);\n        }\n        expect(cookie.httpOnly).toBe(true);\n        expect(cookie.sameSite).toBe('Strict');\n      });\n    });\n\n    test('should invalidate session on logout', async () => {\n      await page.goto('http://localhost:3000/auth/login');\n      \n      // Login\n      await page.fill('input[name=\"email\"]', testUser.email);\n      await page.fill('input[name=\"password\"]', 'TestPassword123!');\n      await page.click('button[type=\"submit\"]');\n      \n      await page.waitForTimeout(1000);\n      \n      // Logout\n      await page.click('[data-testid=\"logout-button\"]');\n      \n      // Should redirect to login\n      await expect(page).toHaveURL(/login|auth/);\n      \n      // Session cookies should be cleared\n      const cookies = await context.cookies();\n      const sessionCookies = cookies.filter(cookie => \n        cookie.name.includes('token') && cookie.value\n      );\n      \n      expect(sessionCookies).toHaveLength(0);\n    });\n  });\n\n  test.describe('Input Validation', () => {\n    test('should validate email format in registration', async () => {\n      await page.goto('http://localhost:3000/auth/register');\n      \n      await page.fill('input[name=\"email\"]', 'invalid-email');\n      await page.fill('input[name=\"password\"]', 'Password123!');\n      await page.fill('input[name=\"confirmPassword\"]', 'Password123!');\n      await page.fill('input[name=\"name\"]', 'Test User');\n      await page.click('button[type=\"submit\"]');\n      \n      // Should show email validation error\n      await expect(page.locator('.error, .invalid')).toContainText(/email|invalid/i);\n    });\n\n    test('should enforce password strength requirements', async () => {\n      await page.goto('http://localhost:3000/auth/register');\n      \n      await page.fill('input[name=\"email\"]', 'test@example.com');\n      await page.fill('input[name=\"password\"]', '123'); // Weak password\n      await page.fill('input[name=\"confirmPassword\"]', '123');\n      await page.fill('input[name=\"name\"]', 'Test User');\n      await page.click('button[type=\"submit\"]');\n      \n      // Should show password strength error\n      await expect(page.locator('.error, .invalid')).toContainText(/password|strength|characters/i);\n    });\n\n    test('should sanitize user input in forms', async () => {\n      await page.goto('http://localhost:3000/auth/register');\n      \n      const maliciousName = '<script>alert(\"XSS\")</script>Evil User';\n      \n      await page.fill('input[name=\"name\"]', maliciousName);\n      \n      // Input should be sanitized (script tags removed)\n      const inputValue = await page.inputValue('input[name=\"name\"]');\n      expect(inputValue).not.toContain('<script>');\n    });\n  });\n\n  test.describe('API Security', () => {\n    test('should require authentication for protected API endpoints', async () => {\n      const response = await page.request.get('http://localhost:3000/api/users/profile');\n      expect(response.status()).toBe(401);\n    });\n\n    test('should validate content-type for POST requests', async () => {\n      const response = await page.request.post('http://localhost:3000/api/auth/login', {\n        headers: {\n          'content-type': 'text/plain', // Wrong content type\n        },\n        data: 'some data',\n      });\n      \n      expect(response.status()).toBe(415); // Unsupported Media Type\n    });\n\n    test('should enforce rate limiting on API endpoints', async () => {\n      const responses = [];\n      \n      // Make many requests quickly\n      for (let i = 0; i < 10; i++) {\n        const response = await page.request.post('http://localhost:3000/api/auth/login', {\n          data: {\n            email: 'test@example.com',\n            password: 'wrongpassword',\n          },\n        });\n        responses.push(response);\n      }\n      \n      // Some requests should be rate limited\n      const rateLimitedResponses = responses.filter(r => r.status() === 429);\n      expect(rateLimitedResponses.length).toBeGreaterThan(0);\n    });\n\n    test('should handle malformed JSON gracefully', async () => {\n      const response = await page.request.post('http://localhost:3000/api/auth/login', {\n        headers: {\n          'content-type': 'application/json',\n        },\n        data: '{invalid json}',\n      });\n      \n      expect(response.status()).toBe(400);\n      const body = await response.json();\n      expect(body.error || body.message).toBeDefined();\n    });\n  });\n\n  test.describe('File Upload Security', () => {\n    test('should validate file types in upload', async () => {\n      // This test would need file upload functionality to be implemented\n      await page.goto('http://localhost:3000/profile');\n      \n      // Check if file input has proper accept attribute\n      const fileInput = page.locator('input[type=\"file\"]');\n      if (await fileInput.count() > 0) {\n        const acceptAttr = await fileInput.getAttribute('accept');\n        expect(acceptAttr).toBeDefined();\n        expect(acceptAttr).not.toBe('*/*'); // Should not accept all files\n      }\n    });\n\n    test('should limit file size in uploads', async () => {\n      // This test would need actual file upload implementation\n      // For now, we check that there are size restrictions in place\n      await page.goto('http://localhost:3000/profile');\n      \n      const fileInput = page.locator('input[type=\"file\"]');\n      if (await fileInput.count() > 0) {\n        // Check for size validation (would need JavaScript validation)\n        const hasValidation = await page.evaluate(() => {\n          const inputs = document.querySelectorAll('input[type=\"file\"]');\n          return Array.from(inputs).some(input => \n            input.hasAttribute('data-max-size') || \n            input.form?.querySelector('[data-file-size-limit]')\n          );\n        });\n        \n        // Should have some form of size validation\n        // expect(hasValidation).toBe(true);\n      }\n    });\n  });\n\n  test.describe('Privacy and Data Protection', () => {\n    test('should display privacy policy', async () => {\n      await page.goto('http://localhost:3000/privacy');\n      \n      // Should have privacy policy content\n      await expect(page.locator('h1, h2')).toContainText(/privacy|personvern/i);\n    });\n\n    test('should display terms of service', async () => {\n      await page.goto('http://localhost:3000/terms');\n      \n      // Should have terms of service content\n      await expect(page.locator('h1, h2')).toContainText(/terms|vilkår/i);\n    });\n\n    test('should show consent options during registration', async () => {\n      await page.goto('http://localhost:3000/auth/register');\n      \n      // Should have consent checkboxes\n      const consentCheckboxes = page.locator('input[type=\"checkbox\"]');\n      await expect(consentCheckboxes).toHaveCountGreaterThan(0);\n      \n      // Should have privacy policy acceptance\n      await expect(page.locator('text=privacy|personvern')).toBeVisible();\n    });\n  });\n\n  test.describe('Error Handling Security', () => {\n    test('should not reveal sensitive information in error messages', async () => {\n      const response = await page.request.get('http://localhost:3000/api/nonexistent-endpoint');\n      \n      expect(response.status()).toBe(404);\n      const body = await response.text();\n      \n      // Should not reveal file paths, database info, etc.\n      expect(body).not.toMatch(/\\/[a-zA-Z]:\\\\/); // Windows paths\n      expect(body).not.toMatch(/\\/home\\/|\\/usr\\/|\\/var\\//); // Unix paths\n      expect(body).not.toMatch(/mysql|postgresql|database/i);\n      expect(body).not.toMatch(/stack trace/i);\n    });\n\n    test('should handle server errors gracefully', async () => {\n      // Try to trigger a server error\n      const response = await page.request.post('http://localhost:3000/api/auth/login', {\n        data: {\n          email: 'a'.repeat(1000), // Very long email\n          password: 'b'.repeat(1000), // Very long password\n        },\n      });\n      \n      // Should return proper error status\n      expect([400, 422, 500]).toContain(response.status());\n      \n      const body = await response.json();\n      expect(body.error || body.message).toBeDefined();\n      expect(body).not.toHaveProperty('stack');\n    });\n  });\n});