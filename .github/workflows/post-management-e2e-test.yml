# üìù Post Management E2E Test Workflow
# 
# This workflow runs end-to-end tests for post management functionality:
# - "Mine annonser" page navigation and post cards display
# - Post detail view navigation from post cards
# - Post edit page access and functionality
# - Post status toggle (Sett Aktiv/Sett Pauset) with state verification
# - Post update workflow with "Lagre endringer" button
# - Edit button functionality from post detail view
# - Requires authenticated user session with existing posts

name: Post Management E2E Test

on:
  pull_request:
    branches: [ main ]

env:
  NODE_ENV: production

permissions:
  contents: read
  pull-requests: write

jobs:
  post-management-test:
    name: Test Post Management Flow
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 20
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci --include=dev
      
    - name: Setup environment
      run: |
        echo "NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}" >> $GITHUB_ENV
        echo "NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}" >> $GITHUB_ENV
        echo "SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" >> $GITHUB_ENV
        echo "JWT_ACCESS_SECRET=${{ secrets.JWT_ACCESS_SECRET }}" >> $GITHUB_ENV
        echo "JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}" >> $GITHUB_ENV
        echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> $GITHUB_ENV
        echo "TESTER_PASSWORD=${{ secrets.TESTER_PASSWORD }}" >> $GITHUB_ENV
        echo "ALLOW_TEST_SETUP=true" >> $GITHUB_ENV
        
    - name: Build application
      run: npm run build
      
    - name: Install Playwright
      run: npx playwright install --with-deps chromium
      
    - name: Start application
      run: |
        npm run start &
        sleep 10
        curl --retry 10 --retry-delay 5 --retry-connrefused http://localhost:3000
      
    - name: Run post management E2E test
      run: |
        cat > playwright-post-management.config.ts << 'EOF'
        import { defineConfig } from '@playwright/test';

        export default defineConfig({
          testDir: './tests/e2e',
          timeout: 45000,
          expect: { timeout: 8000 },
          fullyParallel: false,
          forbidOnly: !!process.env.CI,
          retries: process.env.CI ? 2 : 0,
          workers: 1,
          reporter: 'html',
          use: {
            baseURL: 'http://localhost:3000',
            trace: 'on-first-retry',
            screenshot: 'only-on-failure',
          },
          projects: [
            {
              name: 'chromium',
              use: { browserName: 'chromium' },
            },
          ],
        });
        EOF
        
        mkdir -p tests/e2e
        cat > tests/e2e/post-management.test.ts << 'EOF'
        import { test, expect } from '@playwright/test';

        test.describe('Post Management Flow', () => {
          test.beforeEach(async ({ page }) => {
            // Login with test user
            await page.goto('/auth/login');
            await page.fill('input[type="email"]', 'tester@tutorconnect.no');
            await page.fill('input[type="password"]', process.env.TESTER_PASSWORD || '');
            
            let loginResponse;
            await Promise.all([
              page.waitForResponse(response => response.url().includes('/api/auth/login'), { timeout: 10000 }).then(res => { loginResponse = res; }),
              page.click('button[type="submit"]')
            ]);
            
            // Check login response
            if (loginResponse) {
              const responseData = await loginResponse.json().catch(() => ({}));
              console.log('Login response status:', loginResponse.status());
              console.log('Login response data:', JSON.stringify(responseData, null, 2));
              
              // Verify login was successful
              expect(loginResponse.status()).toBe(200);
            }
            
            await page.waitForTimeout(3000);
            
            // Navigate to home page
            await page.goto('/');
            await page.waitForTimeout(2000);
          });

          test('should complete full post management workflow', async ({ page }) => {
            const currentUrl = await page.url();
            expect(currentUrl).toContain('localhost:3000');

            console.log('‚úÖ Starting post management workflow test');

            // Test 1: Navigate to "Mine annonser" page
            console.log('üß™ Test 1: Navigate to Mine annonser page');
            
            // Wait for the page to fully load after login
            await page.waitForTimeout(5000);
            
            // Debug what's on the page
            const pageTitle = await page.title();
            const currentUrl = await page.url();
            console.log(`üîç Current page: ${pageTitle} at ${currentUrl}`);
            
            // Look for any links containing "Mine annonser" or similar text
            const allLinks = await page.locator('a').allTextContents();
            console.log('üîç All links on page:', allLinks.slice(0, 15)); // Show first 15 links
            
            // Try various selectors for Mine annonser
            const mineAnnonserSelectors = [
              'a:has-text("Mine annonser")',
              'a[href="/profile/posts"]', 
              'nav a:has-text("Mine annonser")',
              'aside a:has-text("Mine annonser")',
              '.sidebar a:has-text("Mine annonser")',
              'a:has-text("annonser")',
              'a[href*="posts"]'
            ];
            
            let mineAnnonserLink = null;
            for (const selector of mineAnnonserSelectors) {
              const link = page.locator(selector);
              if (await link.isVisible({ timeout: 2000 })) {
                console.log(`‚úÖ Found Mine annonser link with selector: ${selector}`);
                mineAnnonserLink = link;
                break;
              }
            }
            
            if (!mineAnnonserLink) {
              // If still not found, check if there's any navigation menu to open first
              const menuButton = page.locator('button[aria-label*="menu"], button:has([data-testid="hamburger"]), .menu-button');
              if (await menuButton.isVisible({ timeout: 3000 })) {
                console.log('üîß Opening navigation menu first');
                await menuButton.click();
                await page.waitForTimeout(2000);
                
                // Try again after opening menu
                for (const selector of mineAnnonserSelectors) {
                  const link = page.locator(selector);
                  if (await link.isVisible({ timeout: 2000 })) {
                    console.log(`‚úÖ Found Mine annonser link after opening menu: ${selector}`);
                    mineAnnonserLink = link;
                    break;
                  }
                }
              }
            }
            
            if (!mineAnnonserLink) {
              throw new Error('Could not find Mine annonser link with any selector. Available links: ' + allLinks.slice(0, 10).join(', '));
            }
            
            await mineAnnonserLink.click();
            await page.waitForTimeout(2000);
            
            // Verify we're on the correct page
            await expect(page).toHaveURL('/profile/posts');
            await expect(page.locator('h1:has-text("Mine annonser")')).toBeVisible({ timeout: 10000 });
            console.log('‚úÖ Successfully navigated to Mine annonser page');

            // Verify we successfully reached the page
            const currentPageUrl = await page.url();
            expect(currentPageUrl).toContain('/profile/posts');

            // Test 2: Check for post cards and click first one
            console.log('üß™ Test 2: Click first post card');
            
            await page.waitForTimeout(3000); // Wait for posts to load
            
            const postCards = page.locator('a[href^="/posts/"]:not([href*="/edit"])');
            const postCardCount = await postCards.count();
            
            expect(postCardCount).toBeGreaterThan(0);
            console.log(`‚úÖ Found ${postCardCount} post cards`);
              
            const firstPostCard = postCards.first();
            const postHref = await firstPostCard.getAttribute('href');
            console.log(`üîó First post URL: ${postHref}`);
            
            await firstPostCard.click();
            await page.waitForTimeout(3000);
            
            // Verify we're on post detail page
            const detailUrl = await page.url();
            expect(detailUrl).toMatch(/\/posts\/[^\/]+$/);
            expect(detailUrl).not.toContain('/edit');
            console.log('‚úÖ Successfully navigated to post detail page');
                
            // Store the post ID for later use
            const postId = detailUrl.split('/posts/')[1];
            console.log(`üìù Post ID: ${postId}`);
            
            // Test 3: Go back to Mine annonser
            console.log('üß™ Test 3: Return to Mine annonser page');
            await page.goto('/profile/posts');
            await page.waitForTimeout(3000);
            
            // Test 4: Click edit button on first post
            console.log('üß™ Test 4: Click edit button on first post');
            
            const editButton = page.locator('a[href*="/edit"]').first();
            await expect(editButton).toBeVisible({ timeout: 5000 });
            await editButton.click();
            await page.waitForTimeout(3000);
            
            const editUrl = await page.url();
            expect(editUrl).toContain('/edit');
            console.log('‚úÖ Successfully navigated to edit page');
                    
            // Test 5: Test status toggle buttons
            console.log('üß™ Test 5: Test status toggle functionality');
            
            // Look for either "Set Aktiv" or "Set Pauset" button (note: no "t" in "Set")
            const setAktivBtn = page.locator('button:has-text("Set Aktiv")');
            const setPausetBtn = page.locator('button:has-text("Set Pauset")');
            
            let statusButton;
            let initialButtonText;
            let toggledButtonText;
            
            // Wait a bit for the page to load completely
            await page.waitForTimeout(2000);
            
            if (await setAktivBtn.isVisible({ timeout: 5000 })) {
              statusButton = setAktivBtn;
              initialButtonText = "Set Aktiv";
              toggledButtonText = "Set Pauset";
              console.log('‚úÖ Found "Set Aktiv" button');
            } else if (await setPausetBtn.isVisible({ timeout: 5000 })) {
              statusButton = setPausetBtn;
              initialButtonText = "Set Pauset";
              toggledButtonText = "Set Aktiv";
              console.log('‚úÖ Found "Set Pauset" button');
            } else {
              // Debug what buttons are actually on the page
              const allButtons = await page.locator('button').allTextContents();
              console.log('üîç All buttons on page:', allButtons);
              throw new Error('Status toggle button not found. Available buttons: ' + allButtons.join(', '));
            }
            
            expect(statusButton).toBeTruthy();
            console.log(`‚úÖ Found status button: ${initialButtonText}`);
            
            // First toggle
            await statusButton.click();
            console.log(`üîÑ Clicked ${initialButtonText} button, waiting for status change...`);
            await page.waitForTimeout(4000);
            
            // Check if button text changed
            const newButton = page.locator(`button:has-text("${toggledButtonText}")`);
            await expect(newButton).toBeVisible({ timeout: 10000 });
            console.log(`‚úÖ Status toggled successfully: ${initialButtonText} ‚Üí ${toggledButtonText}`);
            
            // Second toggle (back to original)
            console.log(`üîÑ Clicking ${toggledButtonText} button to toggle back...`);
            await newButton.click();
            await page.waitForTimeout(4000);
            
            // Wait for the status to update (shorter wait, no networkidle)
            await page.waitForTimeout(3000);
            
            // Look for the original button again
            console.log(`üîç Looking for ${initialButtonText} button after toggle...`);
            const originalButton = page.locator(`button:has-text("${initialButtonText}")`);
            
            // Try to find the button with some retries
            let buttonFound = false;
            for (let i = 0; i < 3; i++) {
              if (await originalButton.isVisible({ timeout: 2000 })) {
                buttonFound = true;
                break;
              }
              
              console.log(`üîÑ Retry ${i + 1}: Button not found, waiting...`);
              await page.waitForTimeout(2000);
              
              // Debug what buttons are available
              const allButtons = await page.locator('button').allTextContents();
              console.log(`üîç Available buttons (retry ${i + 1}):`, allButtons);
              
              // Check if we're still on the edit page
              const currentUrl = await page.url();
              console.log('üîç Current URL:', currentUrl);
              
              if (!currentUrl.includes('/edit')) {
                console.log('‚ö†Ô∏è Navigated away from edit page, going back');
                await page.goBack();
                await page.waitForTimeout(2000);
              }
            }
            
            // Strict validation: the exact original button must be visible after second toggle
            if (!buttonFound) {
              const finalButtons = await page.locator('button').allTextContents();
              console.log('‚ùå Final button state:', finalButtons);
              throw new Error(`Status toggle failed: Expected "${initialButtonText}" button but not found after second toggle`);
            }
            
            await expect(originalButton).toBeVisible({ timeout: 2000 });
            console.log(`‚úÖ Status toggled back successfully: ${toggledButtonText} ‚Üí ${initialButtonText}`);
                      
            // Test 6: Save changes and verify navigation to post detail
            console.log('üß™ Test 6: Save changes and return to post detail');
            
            const saveButton = page.locator('button:has-text("Lagre endringer")');
            await expect(saveButton).toBeVisible({ timeout: 5000 });
            await saveButton.click();
            await page.waitForTimeout(3000);
            
            const savedUrl = await page.url();
            expect(savedUrl).toMatch(/\/posts\/[^\/]+$/);
            expect(savedUrl).not.toContain('/edit');
            console.log('‚úÖ Successfully saved and returned to post detail page');
            
            // Test 7: Click "Rediger" button from detail page
            console.log('üß™ Test 7: Click Rediger button from post detail page');
            
            const redigerButton = page.locator('button:has-text("Rediger")');
            await expect(redigerButton).toBeVisible({ timeout: 5000 });
            await redigerButton.click();
            await page.waitForTimeout(3000);
            
            const finalEditUrl = await page.url();
            expect(finalEditUrl).toContain('/edit');
            console.log('‚úÖ Successfully navigated to edit page from Rediger button');

            console.log('‚úÖ Post management workflow test completed');
          });
        });
        EOF
        
        npx playwright test --config=playwright-post-management.config.ts
      
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: playwright-post-management-report
        path: playwright-report/
        retention-days: 30