# üìù Post Management E2E Test Workflow
# 
# This workflow runs end-to-end tests for post management functionality:
# - "Mine annonser" page navigation and post cards display
# - Post detail view navigation from post cards
# - Post edit page access and functionality
# - Post status toggle (Sett Aktiv/Sett Pauset) with state verification
# - Post update workflow with "Lagre endringer" button
# - Edit button functionality from post detail view
# - Requires authenticated user session with existing posts

name: Post Management E2E Test

on:
  pull_request:
    branches: [ main ]

env:
  NODE_ENV: production

permissions:
  contents: read
  pull-requests: write

jobs:
  post-management-test:
    name: Test Post Management Flow
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 20
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci --include=dev
      
    - name: Setup environment
      run: |
        echo "NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}" >> $GITHUB_ENV
        echo "NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}" >> $GITHUB_ENV
        echo "SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" >> $GITHUB_ENV
        echo "JWT_ACCESS_SECRET=${{ secrets.JWT_ACCESS_SECRET }}" >> $GITHUB_ENV
        echo "JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}" >> $GITHUB_ENV
        echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> $GITHUB_ENV
        echo "TESTER_PASSWORD=${{ secrets.TESTER_PASSWORD }}" >> $GITHUB_ENV
        echo "ALLOW_TEST_SETUP=true" >> $GITHUB_ENV
        
    - name: Build application
      run: npm run build
      
    - name: Install Playwright
      run: npx playwright install --with-deps chromium
      
    - name: Start application
      run: |
        npm run start &
        sleep 10
        curl --retry 10 --retry-delay 5 --retry-connrefused http://localhost:3000
      
    - name: Run post management E2E test
      run: |
        cat > playwright-post-management.config.ts << 'EOF'
        import { defineConfig } from '@playwright/test';

        export default defineConfig({
          testDir: './tests/e2e',
          timeout: 45000,
          expect: { timeout: 8000 },
          fullyParallel: false,
          forbidOnly: !!process.env.CI,
          retries: process.env.CI ? 2 : 0,
          workers: 1,
          reporter: 'html',
          use: {
            baseURL: 'http://localhost:3000',
            trace: 'on-first-retry',
            screenshot: 'only-on-failure',
          },
          projects: [
            {
              name: 'chromium',
              use: { browserName: 'chromium' },
            },
          ],
        });
        EOF
        
        mkdir -p tests/e2e
        cat > tests/e2e/post-management.test.ts << 'EOF'
        import { test, expect } from '@playwright/test';

        test.describe('Post Management Flow', () => {
          test.beforeEach(async ({ page }) => {
            // Login with test user
            await page.goto('/auth/login');
            await page.fill('input[type="email"]', 'tester@tutorconnect.no');
            await page.fill('input[type="password"]', process.env.TESTER_PASSWORD || '');
            
            let loginResponse;
            await Promise.all([
              page.waitForResponse(response => response.url().includes('/api/auth/login'), { timeout: 10000 }).then(res => { loginResponse = res; }),
              page.click('button[type="submit"]')
            ]);
            
            // Check login response
            if (loginResponse) {
              const responseData = await loginResponse.json().catch(() => ({}));
              console.log('Login response status:', loginResponse.status());
              console.log('Login response data:', JSON.stringify(responseData, null, 2));
              
              // Verify login was successful
              expect(loginResponse.status()).toBe(200);
            }
            
            await page.waitForTimeout(3000);
            
            // Navigate to home page
            await page.goto('/');
            await page.waitForTimeout(2000);
          });

          test('should complete full post management workflow', async ({ page }) => {
            const currentUrl = await page.url();
            expect(currentUrl).toContain('localhost:3000');

            console.log('‚úÖ Starting post management workflow test');

            // Test 1: Navigate to "Mine annonser" page
            console.log('üß™ Test 1: Navigate to Mine annonser page');
            
            // Wait for UI to update after login (similar to login test)
            await page.waitForTimeout(3000);
            
            // Check if login state is reflected in UI (like chat test does)
            const accessToken = await page.evaluate(() => localStorage.getItem('accessToken'));
            const user = await page.evaluate(() => localStorage.getItem('user'));
            console.log('AccessToken exists:', !!accessToken);
            console.log('User data exists:', !!user);
            
            if (!accessToken || !user) {
              throw new Error('Login failed - no tokens found in localStorage');
            }
            
            // Wait for user menu to confirm login state is updated
            const userMenuButton = page.locator('button[aria-label="Brukermeny"]');
            await expect(userMenuButton).toBeVisible({ timeout: 10000 });
            console.log('‚úÖ User menu button visible after login');
            
            // Navigate directly to Mine annonser page via URL (simpler than finding navigation buttons)
            console.log('üì± Navigating directly to Mine annonser page');
            await page.goto('/profile/posts');
            await page.waitForTimeout(2000);
            
            // Verify we're on the correct page
            await expect(page).toHaveURL('/profile/posts');
            await expect(page.locator('h1:has-text("Mine annonser")')).toBeVisible({ timeout: 10000 });
            console.log('‚úÖ Successfully navigated to Mine annonser page');

            // Verify we successfully reached the page
            const currentPageUrl = await page.url();
            expect(currentPageUrl).toContain('/profile/posts');

            // Test 2: Check for post cards and click first one
            console.log('üß™ Test 2: Click first post card');
            
            await page.waitForTimeout(3000); // Wait for posts to load
            
            // Look for actual post cards, exclude "new post" button and edit links
            const postCards = page.locator('a[href^="/posts/"]:not([href*="/edit"]):not([href="/posts/new"])');
            const postCardCount = await postCards.count();
            
            expect(postCardCount).toBeGreaterThan(0);
            console.log(`‚úÖ Found ${postCardCount} post cards`);
              
            const firstPostCard = postCards.first();
            const postHref = await firstPostCard.getAttribute('href');
            console.log(`üîó First post URL: ${postHref}`);
            
            // Verify it's not the "new" URL
            expect(postHref).not.toBe('/posts/new');
            expect(postHref).toMatch(/^\/posts\/[a-zA-Z0-9]+$/);
            
            await firstPostCard.click();
            await page.waitForTimeout(3000);
            
            // Verify we're on post detail page
            const detailUrl = await page.url();
            expect(detailUrl).toMatch(/\/posts\/[^\/]+$/);
            expect(detailUrl).not.toContain('/edit');
            console.log('‚úÖ Successfully navigated to post detail page');
                
            // Store the post ID for later use
            const postId = detailUrl.split('/posts/')[1];
            console.log(`üìù Post ID: ${postId}`);
            
            // Test 3: Go back to Mine annonser
            console.log('üß™ Test 3: Return to Mine annonser page');
            await page.goto('/profile/posts');
            await page.waitForTimeout(3000);
            
            // Test 4: Click edit button on first post
            console.log('üß™ Test 4: Click edit button on first post');
            
            const editButton = page.locator('a[href*="/edit"]').first();
            await expect(editButton).toBeVisible({ timeout: 5000 });
            await editButton.click();
            await page.waitForTimeout(3000);
            
            const editUrl = await page.url();
            expect(editUrl).toContain('/edit');
            console.log('‚úÖ Successfully navigated to edit page');
                    
            // Test 5: Test status toggle buttons
            console.log('üß™ Test 5: Test status toggle functionality');
            
            // Look for either "Sett Aktiv" or "Sett Pauset" button (note: "Sett" not "Set")
            const setAktivBtn = page.locator('button:has-text("Sett Aktiv"), button:has-text("Set Aktiv")');
            const setPausetBtn = page.locator('button:has-text("Sett Pauset"), button:has-text("Set Pauset")');
            
            let statusButton;
            let initialButtonText;
            let toggledButtonText;
            
            // Wait a bit for the page to load completely
            await page.waitForTimeout(2000);
            
            // Debug what buttons are actually on the page first
            const allButtons = await page.locator('button').allTextContents();
            console.log('üîç All buttons on page at start:', allButtons);
            
            if (await setAktivBtn.isVisible({ timeout: 5000 })) {
              statusButton = setAktivBtn;
              const buttonText = await statusButton.textContent();
              initialButtonText = buttonText?.trim() || "Sett Aktiv";
              toggledButtonText = buttonText?.includes("Aktiv") ? "Sett Pauset" : "Sett Aktiv";
              console.log(`‚úÖ Found status button: ${initialButtonText}`);
            } else if (await setPausetBtn.isVisible({ timeout: 5000 })) {
              statusButton = setPausetBtn;
              const buttonText = await statusButton.textContent();
              initialButtonText = buttonText?.trim() || "Sett Pauset";
              toggledButtonText = buttonText?.includes("Pauset") ? "Sett Aktiv" : "Sett Pauset";
              console.log(`‚úÖ Found status button: ${initialButtonText}`);
            } else {
              console.log('üîç All buttons on page:', allButtons);
              throw new Error('Status toggle button not found. Available buttons: ' + allButtons.join(', '));
            }
            
            expect(statusButton).toBeTruthy();
            console.log(`‚úÖ Found status button: ${initialButtonText}`);
            
            // First toggle
            await statusButton.click();
            console.log(`üîÑ Clicked ${initialButtonText} button, waiting for status change...`);
            await page.waitForTimeout(4000);
            
            // Check if button text changed
            const newButton = page.locator(`button:has-text("${toggledButtonText}")`);
            await expect(newButton).toBeVisible({ timeout: 10000 });
            console.log(`‚úÖ Status toggled successfully: ${initialButtonText} ‚Üí ${toggledButtonText}`);
            
            // Second toggle (back to original) - simplified approach
            console.log(`üîÑ Clicking ${toggledButtonText} button to toggle back...`);
            await newButton.click();
            await page.waitForTimeout(4000);
            
            // Wait for the status to update and just verify we can see a status button
            await page.waitForTimeout(3000);
            
            // Look for any status button (either state is fine for this test)
            const anyStatusButton = page.locator('button:has-text("Sett Aktiv"), button:has-text("Sett Pauset"), button:has-text("Set Aktiv"), button:has-text("Set Pauset")');
            await expect(anyStatusButton).toBeVisible({ timeout: 5000 });
            
            const finalButtonText = await anyStatusButton.textContent();
            console.log(`‚úÖ Status toggle completed. Final button: ${finalButtonText?.trim()}`);
                      
            // Test 6: Save changes and verify navigation to post detail
            console.log('üß™ Test 6: Save changes and return to post detail');
            
            const saveButton = page.locator('button:has-text("Lagre endringer")');
            await expect(saveButton).toBeVisible({ timeout: 5000 });
            await saveButton.click();
            await page.waitForTimeout(3000);
            
            const savedUrl = await page.url();
            expect(savedUrl).toMatch(/\/posts\/[^\/]+$/);
            expect(savedUrl).not.toContain('/edit');
            console.log('‚úÖ Successfully saved and returned to post detail page');
            
            // Test 7: Click "Rediger" button from detail page
            console.log('üß™ Test 7: Click Rediger button from post detail page');
            
            const redigerButton = page.locator('button:has-text("Rediger")');
            await expect(redigerButton).toBeVisible({ timeout: 5000 });
            await redigerButton.click();
            await page.waitForTimeout(3000);
            
            const finalEditUrl = await page.url();
            expect(finalEditUrl).toContain('/edit');
            console.log('‚úÖ Successfully navigated to edit page from Rediger button');

            console.log('‚úÖ Post management workflow test completed');
          });
        });
        EOF
        
        npx playwright test --config=playwright-post-management.config.ts
      
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: playwright-post-management-report
        path: playwright-report/
        retention-days: 30