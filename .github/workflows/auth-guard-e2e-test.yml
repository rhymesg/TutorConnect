# ðŸ” Auth Guard E2E Test Workflow
# 
# This workflow tests authentication guards for protected pages:
# - Tests redirect to login page when accessing protected pages without authentication
# - Tests proper redirect back to intended page after login
# - Covers protected pages: profile, profile/posts, chat, appointments
# - Uses test user account from environment variables for login testing
# - Ensures logout between tests to maintain clean state

name: Auth Guard E2E Test

on:
  pull_request:
    branches: [ main ]

env:
  NODE_ENV: production
  TESTER_EMAIL: ${{ secrets.TESTER_EMAIL }}
  TESTER_PASSWORD: ${{ secrets.TESTER_PASSWORD }}

permissions:
  contents: read
  pull-requests: write

jobs:
  auth-guard-test:
    name: Test Auth Guard Redirects
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 20
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci --include=dev
      
    - name: Setup environment
      run: |
        echo "NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}" >> $GITHUB_ENV
        echo "NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}" >> $GITHUB_ENV
        echo "SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" >> $GITHUB_ENV
        echo "JWT_ACCESS_SECRET=${{ secrets.JWT_ACCESS_SECRET }}" >> $GITHUB_ENV
        echo "JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}" >> $GITHUB_ENV
        echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> $GITHUB_ENV
        echo "ALLOW_TEST_SETUP=true" >> $GITHUB_ENV
        
    - name: Build application
      run: npm run build
      
    - name: Install Playwright
      run: npx playwright install --with-deps chromium
      
    - name: Start application
      run: |
        npm run start &
        sleep 10
        curl --retry 10 --retry-delay 5 --retry-connrefused http://localhost:3000
      
    - name: Run auth guard E2E test
      run: |
        cat > playwright-auth-guard.config.ts << 'EOF'
        import { defineConfig } from '@playwright/test';

        export default defineConfig({
          testDir: './tests/e2e',
          timeout: 60000,
          expect: { timeout: 10000 },
          fullyParallel: false,
          forbidOnly: !!process.env.CI,
          retries: process.env.CI ? 2 : 0,
          workers: 1,
          reporter: 'html',
          use: {
            baseURL: 'http://localhost:3000',
            trace: 'on-first-retry',
            screenshot: 'only-on-failure',
          },
          projects: [
            {
              name: 'chromium',
              use: { browserName: 'chromium' },
            },
          ],
        });
        EOF
        
        mkdir -p tests/e2e
        cat > tests/e2e/auth-guard.test.ts << 'EOF'
        import { test, expect } from '@playwright/test';

        const PROTECTED_PAGES = [
          { path: '/profile', name: 'Profile' },
          { path: '/profile/posts', name: 'Profile Posts' },
          { path: '/chat', name: 'Chat' },
          { path: '/appointments', name: 'Appointments' }
        ];

        test.describe('Auth Guard Tests', () => {
          // Helper function to ensure logout state
          const ensureLoggedOut = async (page) => {
            // Navigate to home page first to ensure we have a proper document context
            await page.goto('/');
            await page.waitForTimeout(1000);
            
            await page.evaluate(() => {
              localStorage.removeItem('accessToken');
              localStorage.removeItem('user');
              localStorage.removeItem('refreshToken');
            });
            await page.context().clearCookies();
          };

          // Helper function to login
          const loginUser = async (page) => {
            await page.goto('/auth/login');
            await page.fill('input[type="email"]', process.env.TESTER_EMAIL || '');
            await page.fill('input[type="password"]', process.env.TESTER_PASSWORD || '');
            
            const [loginResponse] = await Promise.all([
              page.waitForResponse(response => response.url().includes('/api/auth/login'), { timeout: 15000 }),
              page.click('button[type="submit"]')
            ]);
            
            expect(loginResponse.status()).toBe(200);
            await page.waitForTimeout(2000);
            
            // Verify login was successful
            const accessToken = await page.evaluate(() => localStorage.getItem('accessToken'));
            expect(accessToken).toBeTruthy();
            
            console.log('âœ… Login successful');
          };

          // Helper function to logout
          const logoutUser = async (page) => {
            await page.goto('/');
            await page.waitForTimeout(2000);
            
            // Try to find and click user menu
            try {
              const userMenuButton = page.locator('button[aria-label="Brukermeny"]');
              if (await userMenuButton.isVisible({ timeout: 3000 })) {
                await userMenuButton.click();
                await page.waitForTimeout(1000);
                
                const logoutButton = page.locator('button:has-text("Logg ut")');
                if (await logoutButton.isVisible({ timeout: 2000 })) {
                  await logoutButton.click();
                  await page.waitForTimeout(2000);
                }
              }
            } catch (error) {
              console.log('User menu not found, likely already logged out');
            }
            
            // Force clear tokens
            await ensureLoggedOut(page);
            console.log('âœ… Logout completed');
          };

          test.beforeEach(async ({ page }) => {
            // Ensure clean state before each test
            await ensureLoggedOut(page);
          });

          for (const protectedPage of PROTECTED_PAGES) {
            test(`should redirect to login when accessing ${protectedPage.name} without auth`, async ({ page }) => {
              console.log(`\nðŸ§ª Testing ${protectedPage.name} (${protectedPage.path})`);
              
              // Ensure logged out state (beforeEach already handles this)
              
              // Try to access protected page
              console.log(`ðŸ“ Attempting to access ${protectedPage.path}`);
              await page.goto(protectedPage.path);
              
              // Should be redirected to login page
              await page.waitForTimeout(3000);
              console.log(`ðŸ“ Current URL: ${page.url()}`);
              
              // Check if we're on the login page
              expect(page.url()).toContain('/auth/login');
              await expect(page.locator('h2:has-text("Logg inn")')).toBeVisible({ timeout: 10000 });
              
              console.log(`âœ… ${protectedPage.name}: Successfully redirected to login`);
              
              // Now login and verify redirect to original page
              console.log(`ðŸ” Logging in to access ${protectedPage.path}`);
              await page.fill('input[type="email"]', process.env.TESTER_EMAIL || '');
              await page.fill('input[type="password"]', process.env.TESTER_PASSWORD || '');
              
              const [loginResponse] = await Promise.all([
                page.waitForResponse(response => response.url().includes('/api/auth/login'), { timeout: 15000 }),
                page.click('button[type="submit"]')
              ]);
              
              expect(loginResponse.status()).toBe(200);
              console.log('âœ… Login successful');
              
              // Wait for any redirects to complete
              await page.waitForTimeout(5000);
              
              console.log(`ðŸ“ After login URL: ${page.url()}`);
              
              // Should be redirected back to the original intended page
              expect(page.url()).toContain(protectedPage.path);
              
              // Additional verification based on page type - check for actual page content
              if (protectedPage.path === '/profile') {
                // Profile page might not have a visible title, just check URL is correct
                console.log('âœ… Profile page loaded successfully');
              } else if (protectedPage.path === '/profile/posts') {
                await expect(page.locator('h1')).toContainText('Mine annonser', { timeout: 10000 });
              } else if (protectedPage.path === '/chat') {
                await expect(page.locator('h2')).toContainText('Samtaler', { timeout: 10000 });
              } else if (protectedPage.path === '/appointments') {
                await expect(page.locator('h1, h2')).toContainText('Mine timer', { timeout: 10000 });
              }
              
              console.log(`âœ… ${protectedPage.name}: Successfully redirected to intended page after login`);
              
              // Logout for next test
              await logoutUser(page);
              console.log(`âœ… ${protectedPage.name}: Test completed and logged out\n`);
            });
          }

          test('should maintain redirect URL through login process', async ({ page }) => {
            console.log('\nðŸ§ª Testing redirect URL preservation');
            
            // Clean state already ensured by beforeEach
            
            // Try to access a specific protected page
            const targetPage = '/profile';
            await page.goto(targetPage);
            await page.waitForTimeout(3000);
            
            // Should be on login page
            expect(page.url()).toContain('/auth/login');
            
            // Check if redirect parameter is preserved (if implemented)
            const currentUrl = page.url();
            console.log(`ðŸ“ Login URL: ${currentUrl}`);
            
            // Login
            await loginUser(page);
            
            // Should redirect back to target page
            await page.waitForTimeout(3000);
            expect(page.url()).toContain(targetPage);
            
            console.log('âœ… Redirect URL preservation test passed');
            
            // Cleanup
            await logoutUser(page);
          });

          test('should handle multiple protected page access attempts', async ({ page }) => {
            console.log('\nðŸ§ª Testing multiple protected page access attempts');
            
            // Clean state already ensured by beforeEach
            
            // Try accessing multiple pages while logged out
            for (const protectedPage of PROTECTED_PAGES.slice(0, 2)) { // Test first 2 pages
              await page.goto(protectedPage.path);
              await page.waitForTimeout(2000);
              expect(page.url()).toContain('/auth/login');
              console.log(`âœ… ${protectedPage.name}: Correctly redirected to login`);
            }
            
            // Login once
            await loginUser(page);
            
            // Now all protected pages should be accessible
            for (const protectedPage of PROTECTED_PAGES.slice(0, 2)) {
              await page.goto(protectedPage.path);
              await page.waitForTimeout(3000);
              expect(page.url()).toContain(protectedPage.path);
              console.log(`âœ… ${protectedPage.name}: Accessible after login`);
            }
            
            console.log('âœ… Multiple protected page access test passed');
            
            // Cleanup
            await logoutUser(page);
          });
        });
        EOF
        
        npx playwright test --config=playwright-auth-guard.config.ts
      
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: playwright-auth-guard-report
        path: playwright-report/
        retention-days: 30